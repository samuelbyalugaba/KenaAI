{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/intelligent-chat-summary.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview This file defines a Genkit flow for summarizing long chat threads using AI.\n *\n * The flow takes a chat thread as input and returns a concise summary of the conversation's key points.\n *\n * @interface IntelligentChatSummaryInput - Defines the input schema for the intelligentChatSummary function.\n * @interface IntelligentChatSummaryOutput - Defines the output schema for the intelligentChatSummary function.\n * @function intelligentChatSummary - A wrapper function that calls the intelligentChatSummaryFlow with the input and returns the output.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst IntelligentChatSummaryInputSchema = z.object({\n  chatThread: z\n    .string()\n    .describe('The complete chat thread to be summarized.'),\n});\n\nexport type IntelligentChatSummaryInput = z.infer<\n  typeof IntelligentChatSummaryInputSchema\n>;\n\nconst IntelligentChatSummaryOutputSchema = z.object({\n  summary: z.string().describe('A concise summary of the chat thread.'),\n});\n\nexport type IntelligentChatSummaryOutput = z.infer<\n  typeof IntelligentChatSummaryOutputSchema\n>;\n\nexport async function intelligentChatSummary(\n  input: IntelligentChatSummaryInput\n): Promise<IntelligentChatSummaryOutput> {\n  return intelligentChatSummaryFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'intelligentChatSummaryPrompt',\n  input: {schema: IntelligentChatSummaryInputSchema},\n  output: {schema: IntelligentChatSummaryOutputSchema},\n  prompt: `You are an AI expert specializing in summarizing chat threads.\n\n  Please provide a concise summary of the key points in the following chat thread:\n  \\\"{{{chatThread}}}\\\".\n  The summary should be no more than 200 words.\n  `,\n});\n\nconst intelligentChatSummaryFlow = ai.defineFlow(\n  {\n    name: 'intelligentChatSummaryFlow',\n    inputSchema: IntelligentChatSummaryInputSchema,\n    outputSchema: IntelligentChatSummaryOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;;IAiCsB,yBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IAsIsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IAwBsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IA4CsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IAuFsB,4BAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IA6GsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        return agents.map(agent => ({\n            ...agent,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n\n        if (result.insertedId) {\n            const createdAnnouncement = {\n                ...newAnnouncement,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: data.companyId,\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agent && agent.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agent.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agent;\n          const agentWithoutPassword: Agent = {\n            ...agentData,\n            _id: agent._id.toString(),\n            id: agent._id.toString(),\n            companyId: agent.companyId?.toString(),\n          };\n          return { success: true, agent: agentWithoutPassword };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgent = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgent) {\n                const { password, ...agentData } = newAgent;\n                const agentWithoutPassword: Agent = {\n                  ...agentData,\n                  _id: newAgent._id.toString(),\n                  id: newAgent._id.toString(),\n                  companyId: newAgent.companyId?.toString(),\n                };\n                return { success: true, agent: agentWithoutPassword };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n\n            const newAgent = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgent) {\n                 const { password, ...agentData } = newAgent;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgent._id.toString(),\n                    id: newAgent._id.toString(),\n                    companyId: newAgent.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n"],"names":[],"mappings":";;;;;;IAkLsB,eAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["\n\"use client\";\n\nimport * as React from \"react\";\nimport { ChatLayout } from \"@/components/dashboard/chat-layout\";\nimport { VerticalNav } from \"@/components/dashboard/vertical-nav\";\nimport { ContactsView } from \"@/components/dashboard/contacts-view\";\nimport { AgentsView } from \"@/components/dashboard/agents-view\";\nimport { DashboardView } from \"@/components/dashboard/dashboard-view\";\nimport type { Agent, UserProfile } from \"@/types\";\nimport { AnnouncementsView } from \"@/components/dashboard/announcements-view\";\nimport { SettingsDialog } from \"@/components/dashboard/settings-dialog\";\nimport { CampaignsView } from \"@/components/dashboard/campaigns-view\";\nimport { MyPerformanceView } from \"@/components/dashboard/my-performance-view\";\nimport { AuthForm } from \"@/components/dashboard/auth-form\";\nimport { handleLogin, handleSignUp } from \"@/app/actions\";\nimport { useToast } from \"@/hooks/use-toast\";\n\n\nexport type View = \"Chat\" | \"Contacts\" | \"Agents\" | \"Dashboard\" | \"Announcements\" | \"History\" | \"Payments\" | \"Settings\" | \"System Settings\" | \"Campaigns\" | \"My Performance\";\n\nexport default function Home({ params, searchParams }: { params: {}; searchParams: {} }) {\n  React.use(params);\n  React.use(searchParams);\n  \n  const [activeView, setActiveView] = React.useState<View>(\"Chat\");\n  const [isNavOpen, setIsNavOpen] = React.useState(false);\n  const [currentUser, setCurrentUser] = React.useState<UserProfile | null>(null);\n  const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);\n  const { toast } = useToast();\n\n  const onLogin = async (email: string, password_unused: string) => {\n    const result = await handleLogin(email, password_unused);\n    if (result.success && result.agent) {\n      const agent = result.agent as Agent;\n       setCurrentUser({\n        id: agent.id,\n        name: agent.name,\n        avatar: agent.avatar,\n        role: agent.role,\n        email: agent.email,\n        phone: agent.phone,\n        companyId: agent.companyId,\n      } as UserProfile);\n\n      if (agent.role === 'admin') {\n        setActiveView('Dashboard');\n      } else {\n        setActiveView('Chat');\n      }\n    }\n    return { success: result.success, message: result.message };\n  }\n  \n  const onSignUp = async (name: string, email: string, password_unused: string) => {\n    const result = await handleSignUp(name, email, password_unused);\n    if (result.success && result.agent) {\n        toast({\n            title: \"Account Created!\",\n            description: \"You can now sign in with your new credentials.\",\n        });\n        const agent = result.agent as Agent;\n         setCurrentUser({\n          id: agent.id,\n          name: agent.name,\n          avatar: agent.avatar,\n          role: agent.role,\n          email: agent.email,\n          phone: agent.phone,\n          companyId: agent.companyId,\n        } as UserProfile);\n\n        if (agent.role === 'admin') {\n          setActiveView('Dashboard');\n        } else {\n          setActiveView('Chat');\n        }\n    }\n    return result;\n  }\n\n  const handleLogout = () => {\n    setCurrentUser(null);\n    setActiveView('Chat');\n  };\n  \n  const handleUpdateUser = (updatedUser: Partial<UserProfile>) => {\n    setCurrentUser(prev => prev ? { ...prev, ...updatedUser } : null);\n  }\n\n  const renderView = () => {\n    const props = { onMenuClick: () => setIsNavOpen(true), user: currentUser };\n    switch (activeView) {\n      case \"Chat\":\n        return <ChatLayout user={currentUser} onMenuClick={() => setIsNavOpen(true)} />;\n      case \"Contacts\":\n        return <ContactsView {...props} />;\n      case \"Agents\":\n        return <AgentsView {...props} />;\n      case \"Dashboard\":\n        return <DashboardView {...props} />;\n      case \"Announcements\":\n        return <AnnouncementsView {...props} />;\n      case \"My Performance\":\n        return <MyPerformanceView {...props} />;\n      case \"Campaigns\":\n         return <CampaignsView {...props} />;\n      default:\n        return <ChatLayout user={currentUser} onMenuClick={() => setIsNavOpen(true)} />;\n    }\n  };\n\n  if (!currentUser) {\n    return (\n      <main className=\"flex h-screen w-full items-center justify-center bg-background p-4 overflow-hidden auth-page-background\">\n        <AuthForm onLogin={onLogin} onSignUp={onSignUp} />\n      </main>\n    );\n  }\n\n  return (\n    <main className=\"flex h-screen bg-background\">\n      <SettingsDialog \n        open={isSettingsOpen} \n        onOpenChange={setIsSettingsOpen} \n        user={currentUser}\n        onUserUpdate={handleUpdateUser}\n      />\n      <VerticalNav \n          activeView={activeView} \n          setActiveView={setActiveView} \n          user={currentUser}\n          onLogout={handleLogout}\n          isOpen={isNavOpen}\n          setIsOpen={setIsNavOpen}\n          onSettingsClick={() => setIsSettingsOpen(true)}\n      />\n      <div className=\"flex-1 md:pl-[70px] min-w-0\">\n          {renderView()}\n      </div>\n    </main>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/hooks/use-mobile.tsx"],"sourcesContent":["import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n"],"names":[],"mappings":";;;AAAA;;;AAEA,MAAM,oBAAoB;AAEnB,SAAS;;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAuB;IAEpE,CAAA,GAAA,6JAAA,CAAA,YAAe,AAAD;iCAAE;YACd,MAAM,MAAM,OAAO,UAAU,CAAC,CAAC,YAAY,EAAE,oBAAoB,EAAE,GAAG,CAAC;YACvE,MAAM;kDAAW;oBACf,YAAY,OAAO,UAAU,GAAG;gBAClC;;YACA,IAAI,gBAAgB,CAAC,UAAU;YAC/B,YAAY,OAAO,UAAU,GAAG;YAChC;yCAAO,IAAM,IAAI,mBAAmB,CAAC,UAAU;;QACjD;gCAAG,EAAE;IAEL,OAAO,CAAC,CAAC;AACX;GAdgB","debugId":null}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/hooks/use-theme.ts"],"sourcesContent":["\n\"use client\"\n\nimport { useContext } from \"react\"\nimport {\n  ThemeContext,\n  type ThemeContextType,\n} from \"@/components/ui/theme-provider\"\n\nexport const useTheme = (): ThemeContextType => {\n  const context = useContext(ThemeContext)\n  if (context === undefined) {\n    throw new Error(\"useTheme must be used within a ThemeProvider\")\n  }\n  return context\n}\n"],"names":[],"mappings":";;;AAGA;AACA;;AAHA;;;AAQO,MAAM,WAAW;;IACtB,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE,gJAAA,CAAA,eAAY;IACvC,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;GANa","debugId":null}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/mock-data.ts"],"sourcesContent":["\n\nimport type { Agent, Chat, User, AgentPerformance, UnansweredQuery } from \"@/types\";\n\nexport const mockAdminUser: Agent = { \n    id: '1', \n    name: \"Samuel Byalugaba\", \n    avatar: \"https://picsum.photos/seed/sam/100/100\", \n    email: \"samuel.b@example.com\", \n    phone: \"+1-555-0201\", \n    role: \"admin\", \n    password: \"password\",\n    status: \"Online\",\n    conversationsToday: 12,\n    avgResponseTime: \"1m 45s\",\n    csat: 98,\n};\n\nexport const mockAgents: Agent[] = [\n    mockAdminUser,\n    { \n        id: '2', \n        name: \"Kelvin Malisa\", \n        avatar: \"https://picsum.photos/seed/kelvin/100/100\", \n        email: \"kelvin.m@example.com\", \n        phone: \"+1-555-0202\", \n        role: \"admin\", \n        password: \"password\",\n        status: \"Online\",\n        conversationsToday: 15,\n        avgResponseTime: \"1m 30s\",\n        csat: 95,\n    },\n    { \n        id: '3', \n        name: \"Sylvester Mayaya\", \n        avatar: \"https://picsum.photos/seed/sly/100/100\", \n        email: \"sylvester.m@example.com\", \n        phone: \"+1-555-0203\", \n        role: \"super_agent\", \n        password: \"password\",\n        status: \"Busy\",\n        conversationsToday: 25,\n        avgResponseTime: \"2m 10s\",\n        csat: 92,\n    },\n    { \n        id: '4', \n        name: \"Linaliz Ready\", \n        avatar: \"https://picsum.photos/seed/linaliz/100/100\", \n        email: \"linaliz.r@example.com\", \n        phone: \"+1-555-0204\", \n        role: \"agent\", \n        password: \"password\",\n        status: \"Offline\",\n        conversationsToday: 8,\n        avgResponseTime: \"3m 05s\",\n        csat: 88,\n    },\n];\n\nexport const mockAgentPerformance: AgentPerformance[] = [\n    { rank: 1, agent: mockAgents[0], conversations: 125, avgResponseTime: \"1m 30s\", resolutionRate: 95 },\n    { rank: 2, agent: mockAgents[1], conversations: 110, avgResponseTime: \"1m 45s\", resolutionRate: 92 },\n    { rank: 3, agent: mockAgents[2], conversations: 98, avgResponseTime: \"2m 05s\", resolutionRate: 88 },\n    { rank: 4, agent: { ...mockAgents[3], id: '5', name: \"New Agent\" }, conversations: 85, avgResponseTime: \"2m 15s\", resolutionRate: 85 },\n]\n\nexport const mockUsers: User[] = [\n  { id: 'user1', name: \"Kelvin\", avatar: \"https://picsum.photos/seed/user-kelvin/100/100\", email: \"kelvin@example.com\", phone: \"+1-555-0101\", assignedAgentId: '3' },\n  { id: 'user2', name: \"Sylvester\", avatar: \"https://picsum.photos/seed/user-sly/100/100\", email: \"sylvester@example.com\", phone: \"+1-555-0102\" },\n  { id: 'user3', name: \"Linaliz\", avatar: \"https://picsum.photos/seed/user-linaliz/100/100\", email: \"linaliz@example.com\", phone: \"+1-555-0103\", assignedAgentId: '4' },\n  { id: 'user4', name: \"Glory\", avatar: \"https://picsum.photos/seed/user-glory/100/100\", email: \"glory@example.com\", phone: \"+1-555-0104\" },\n  { id: 'user5', name: \"Alice\", avatar: \"https://picsum.photos/seed/user-alice/100/100\", email: \"alice@example.com\", phone: \"+1-555-0105\", assignedAgentId: '3' },\n  { id: 'user6', name: \"Bob\", avatar: \"https://picsum.photos/seed/user-bob/100/100\", email: \"bob@example.com\", phone: \"+1-555-0106\" },\n  { id: 'user7', name: \"Charlie\", avatar: \"https://picsum.photos/seed/user-charlie/100/100\", email: \"charlie@example.com\", phone: \"+1-555-0107\" },\n  { id: 'user8', name: \"Diana\", avatar: \"https://picsum.photos/seed/user-diana/100/100\", email: \"diana@example.com\", phone: \"+1-555-0108\", assignedAgentId: '1' },\n];\n\nexport const mockChats: Chat[] = [\n  {\n    id: \"1\",\n    user: mockUsers[0],\n    channel: 'Webchat',\n    lastMessage: \"Absolutely 🎨 We provide ful...\",\n    timestamp: \"10:41 AM\",\n    unreadCount: 0,\n    priority: \"urgent\",\n    isChatbotActive: true,\n    messages: [\n      { id: \"m1\", sender: mockUsers[0], text: \"Hello 👋 What services do you offer?\", timestamp: \"10:38 AM\" },\n      { id: \"m2\", sender: \"me\", text: \"Hi Kelvin! 🚀 We offer web app development, mobile app solutions, and AI-powered chatbots.\", timestamp: \"10:39 AM\" },\n      { id: \"m3\", sender: mockUsers[0], text: \"Nice! Do you also handle design?\", timestamp: \"10:40 AM\" },\n      { id: \"m4\", sender: \"me\", text: \"Absolutely 🎨 We provide full-stack design: UI/UX, branding, and even responsive front-end with React.\", timestamp: \"10:41 AM\" },\n    ],\n  },\n  {\n    id: \"2\",\n    user: mockUsers[1],\n    channel: 'WhatsApp',\n    lastMessage: \"Sure thing! 💡 I’ll schedule...\",\n    timestamp: \"9:20 AM\",\n    unreadCount: 0,\n    priority: \"low\",\n    isChatbotActive: false,\n    messages: [\n      { id: \"m1\", sender: mockUsers[1], text: \"Hi there 👋 Can you help me set up an online store?\", timestamp: \"09:15 AM\" },\n      { id: \"m2\", sender: \"me\", text: \"Hello Sylvester! 🌟 Yes, we specialize in e-commerce platforms with secure payments and inventory management.\", timestamp: \"09:16 AM\" },\n      { id: \"m3\", sender: mockUsers[1], text: \"That sounds great! Do you also integrate delivery tracking?\", timestamp: \"09:17 AM\" },\n      { id: \"m4\", sender: \"me\", text: \"Absolutely 🚚 We can integrate real-time tracking and automated notifications for your customers.\", timestamp: \"09:18 AM\" },\n      { id: \"m5\", sender: mockUsers[1], text: \"Perfect 🙌 I’d love a demo of how it works.\", timestamp: \"09:19 AM\" },\n      { id: \"m6\", sender: \"me\", text: \"Sure thing! 💡 I’ll schedule a quick demo for you this afternoon.\", timestamp: \"09:20 AM\" }\n    ],\n  },\n  {\n    id: \"3\",\n    user: mockUsers[2],\n    channel: 'Instagram',\n    lastMessage: \"Anytime, Linaliz! Let me k...\",\n    timestamp: \"Yesterday\",\n    unreadCount: 0,\n    priority: \"normal\",\n    isChatbotActive: true,\n    messages: [\n      { id: \"m1\", sender: mockUsers[2], text: \"Hello 👋 Could you tell me your business hours?\", timestamp: \"Yesterday\" },\n      { id: \"m2\", sender: \"me\", text: \"Hi Linaliz! 🌸 Yes, we’re open Monday to Friday, from 9:00 AM to 6:00 PM.\", timestamp: \"11:06 AM\" },\n      { id: \"m3\", sender: mockUsers[2], text: \"Great, are you available on weekends too?\", timestamp: \"Yesterday\" },\n      { id: \"m4\", sender: \"me\", text: \"On Saturdays we’re open from 10:00 AM to 2:00 PM ⏰. Sundays we’re closed, but support is still available online.\", timestamp: \"Yesterday\" },\n      { id: \"m5\", sender: mockUsers[2], text: \"Perfect, thanks for clarifying 🙌\", timestamp: \"Yesterday\" },\n      { id: \"m6\", sender: \"me\", text: \"Anytime, Linaliz! Let me know if you’d like me to book you a slot during business hours.\", timestamp: \"Yesterday\" }\n    ],\n  },\n  {\n    id: \"4\",\n    user: mockUsers[3],\n    channel: 'Facebook',\n    lastMessage: \"My order hasn't arri...\",\n    timestamp: \"Yesterday\",\n    unreadCount: 1,\n    priority: \"high\",\n    isChatbotActive: false,\n    messages: [\n      { id: \"m1\", sender: mockUsers[3], text: \"Hi, I placed an order three weeks ago but it still hasn’t arrived 😟\", timestamp: \"02:15 PM\" },\n      { id: \"m2\", sender: \"me\", text: \"Hello Glory! 🤖 I’m checking your order details. Please provide your order number.\", timestamp: \"02:16 PM\" },\n      { id: \"m3\", sender: mockUsers[3], text: \"Sure, it’s #ORD4582\", timestamp: \"02:17 PM\" },\n      { id: \"m4\", sender: \"me\", text: \"Thanks! 🔍 This looks like it may need special assistance. Transferring you to a human support agent...\", timestamp: \"02:18 PM\" },\n      { id: \"m5\", sender: \"me\", text: \"Hi Glory, this is Sylvester from support 👋 I’ll personally look into your order.\", timestamp: \"02:19 PM\" },\n      { id: \"m6\", sender: \"me\", text: \"I see your package was delayed at the courier’s end 🚚. I’ll escalate this and request priority shipping.\", timestamp: \"02:20 PM\" },\n      { id: \"m7\", sender: mockUsers[3], text: \"Okay, I really hope it arrives soon. I’ve been waiting a long time.\", timestamp: \"02:21 PM\" },\n    ]\n  },\n  {\n    id: \"5\",\n    user: mockUsers[4],\n    channel: 'Webchat',\n    lastMessage: \"Yes, we have a student discount.\",\n    timestamp: \"2 days ago\",\n    unreadCount: 0,\n    priority: \"low\",\n    isChatbotActive: false,\n    messages: [\n       { id: \"m1\", sender: mockUsers[4], text: \"Do you offer student discounts?\", timestamp: \"2 days ago\" },\n       { id: \"m2\", sender: \"me\", text: \"Yes, we have a student discount.\", timestamp: \"2 days ago\" },\n    ],\n  },\n  {\n    id: \"6\",\n    user: mockUsers[5],\n    channel: 'WhatsApp',\n    lastMessage: \"Can I change my delivery address?\",\n    timestamp: \"2 days ago\",\n    unreadCount: 2,\n    priority: \"normal\",\n    isChatbotActive: false,\n    messages: [\n        { id: \"m1\", sender: mockUsers[5], text: \"Can I change my delivery address?\", timestamp: \"2 days ago\" },\n    ],\n  },\n  {\n    id: \"7\",\n    user: mockUsers[6],\n    channel: 'Instagram',\n    lastMessage: \"What's your return policy?\",\n    timestamp: \"3 days ago\",\n    unreadCount: 0,\n    priority: \"normal\",\n    isChatbotActive: true,\n    messages: [\n      { id: \"m1\", sender: mockUsers[6], text: \"What's your return policy?\", timestamp: \"3 days ago\" },\n      { id: \"m2\", sender: \"me\", text: \"You can return any item within 30 days of purchase.\", timestamp: \"3 days ago\" },\n    ],\n  },\n  {\n    id: \"8\",\n    user: mockUsers[7],\n    channel: 'Facebook',\n    lastMessage: \"The app is crashing on startup.\",\n    timestamp: \"4 days ago\",\n    unreadCount: 0,\n    priority: \"urgent\",\n    isChatbotActive: false,\n    messages: [\n      { id: \"m1\", sender: mockUsers[7], text: \"The app is crashing on startup.\", timestamp: \"4 days ago\" },\n      { id: \"m2\", sender: \"me\", text: \"We're sorry to hear that. Could you tell me which device you are using?\", timestamp: \"4 days ago\" },\n    ],\n  },\n];\n\nexport const mockUnansweredQueries: UnansweredQuery[] = [\n    { id: 'uq1', query: \"Do you ship to Mars?\", timestamp: \"2 hours ago\", status: 'pending' },\n    { id: 'uq2', query: \"Can I pay with cryptocurrency?\", timestamp: \"5 hours ago\", status: 'pending' },\n    { id: 'uq3', query: \"What is the meaning of life?\", timestamp: \"1 day ago\", status: 'resolved' },\n    { id: 'uq4', query: \"How do I reset my password if I forgot my email?\", timestamp: \"2 days ago\", status: 'pending' },\n];\n"],"names":[],"mappings":"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","debugId":null}}]
}
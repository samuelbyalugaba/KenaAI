{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA0UsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAunBsB,oBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAkqBsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA0sBsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAovBsB,mBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAkwBsB,gBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAwfsB,uBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA2kBsB,mBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA6jBsB,uBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA4EsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAo5BsB,wBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAmhBsB,gBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAkXsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAmesB,kBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAqPsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA+HsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 263, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA6KsB,4BAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAuMsB,yBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAqNsB,2BAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA83BsB,wBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IA6zBsB,iBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAgTsB,cAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const avatar = `https://picsum.photos/seed/${contact.name.replace(/\\s/g, '')}/100/100`;\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar,\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n    \n"],"names":[],"mappings":";;;;;;IAwZsB,eAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["\n\"use client\";\n\nimport * as React from \"react\";\nimport { ChatLayout } from \"@/components/dashboard/chat-layout\";\nimport { VerticalNav } from \"@/components/dashboard/vertical-nav\";\nimport { ContactsView } from \"@/components/dashboard/contacts-view\";\nimport { AgentsView } from \"@/components/dashboard/agents-view\";\nimport { DashboardView } from \"@/components/dashboard/dashboard-view\";\nimport type { Agent, User, UserProfile } from \"@/types\";\nimport { AnnouncementsView } from \"@/components/dashboard/announcements-view\";\nimport { SettingsDialog } from \"@/components/dashboard/settings-dialog\";\nimport { CampaignsView } from \"@/components/dashboard/campaigns-view\";\nimport { MyPerformanceView } from \"@/components/dashboard/my-performance-view\";\nimport { AuthForm } from \"@/components/dashboard/auth-form\";\nimport { handleLogin, handleSignUp } from \"@/app/actions\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { LoadingScreen } from \"@/components/dashboard/loading-screen\";\n\n\nexport type View = \"Chat\" | \"Contacts\" | \"Agents\" | \"Dashboard\" | \"Announcements\" | \"History\" | \"Payments\" | \"Settings\" | \"System Settings\" | \"Campaigns\" | \"My Performance\";\n\nexport default function Home({ params, searchParams }: { params: {}; searchParams: {} }) {\n  React.use(params);\n  React.use(searchParams);\n  \n  const [activeView, setActiveView] = React.useState<View>(\"Chat\");\n  const [isNavOpen, setIsNavOpen] = React.useState(false);\n  const [currentUser, setCurrentUser] = React.useState<UserProfile | null>(null);\n  const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);\n  const [initialContact, setInitialContact] = React.useState<User | null>(null);\n  const [isLoading, setIsLoading] = React.useState(true);\n  const { toast } = useToast();\n\n  React.useEffect(() => {\n    const timer = setTimeout(() => {\n        setIsLoading(false);\n    }, 1500);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const onLogin = async (email: string, password_unused: string) => {\n    const result = await handleLogin(email, password_unused);\n    if (result.success && result.agent) {\n      const agent = result.agent as Agent;\n       setCurrentUser({\n        id: agent.id,\n        name: agent.name,\n        avatar: agent.avatar,\n        role: agent.role,\n        email: agent.email,\n        phone: agent.phone,\n        companyId: agent.companyId,\n      } as UserProfile);\n\n      if (agent.role === 'admin') {\n        setActiveView('Dashboard');\n      } else {\n        setActiveView('Chat');\n      }\n    }\n    return { success: result.success, message: result.message };\n  }\n  \n  const onSignUp = async (name: string, email: string, password_unused: string) => {\n    const result = await handleSignUp(name, email, password_unused);\n    if (result.success && result.agent) {\n        toast({\n            title: \"Account Created!\",\n            description: \"You can now sign in with your new credentials.\",\n        });\n        const agent = result.agent as Agent;\n         setCurrentUser({\n          id: agent.id,\n          name: agent.name,\n          avatar: agent.avatar,\n          role: agent.role,\n          email: agent.email,\n          phone: agent.phone,\n          companyId: agent.companyId,\n        } as UserProfile);\n\n        if (agent.role === 'admin') {\n          setActiveView('Dashboard');\n        } else {\n          setActiveView('Chat');\n        }\n    }\n    return result;\n  }\n\n  const handleLogout = () => {\n    setCurrentUser(null);\n    setActiveView('Chat');\n  };\n  \n  const handleUpdateUser = (updatedUser: Partial<UserProfile>) => {\n    setCurrentUser(prev => prev ? { ...prev, ...updatedUser } : null);\n  }\n\n  const handleNavigateToChat = (contact: User) => {\n    setInitialContact(contact);\n    setActiveView(\"Chat\");\n    // Reset initialContact after a short delay to allow ChatLayout to pick it up\n    setTimeout(() => setInitialContact(null), 100);\n  }\n\n  const renderView = () => {\n    const props = { onMenuClick: () => setIsNavOpen(true), user: currentUser };\n    switch (activeView) {\n      case \"Chat\":\n        return <ChatLayout {...props} initialContact={initialContact} />;\n      case \"Contacts\":\n        return <ContactsView {...props} onNavigateToChat={handleNavigateToChat} />;\n      case \"Agents\":\n        return <AgentsView {...props} />;\n      case \"Dashboard\":\n        return <DashboardView {...props} />;\n      case \"Announcements\":\n        return <AnnouncementsView {...props} />;\n      case \"My Performance\":\n        return <MyPerformanceView {...props} />;\n      case \"Campaigns\":\n         return <CampaignsView {...props} />;\n      default:\n        return <ChatLayout user={currentUser} onMenuClick={() => setIsNavOpen(true)} initialContact={initialContact} />;\n    }\n  };\n\n  if (isLoading) {\n    return <LoadingScreen />;\n  }\n\n  if (!currentUser) {\n    return (\n      <main className=\"flex h-screen w-full items-center justify-center bg-background p-4 overflow-hidden auth-page-background\">\n        <AuthForm onLogin={onLogin} onSignUp={onSignUp} />\n      </main>\n    );\n  }\n\n  return (\n    <main className=\"flex h-screen bg-background\">\n      <SettingsDialog \n        open={isSettingsOpen} \n        onOpenChange={setIsSettingsOpen} \n        user={currentUser}\n        onUserUpdate={handleUpdateUser}\n      />\n      <VerticalNav \n          activeView={activeView} \n          setActiveView={setActiveView} \n          user={currentUser}\n          onLogout={handleLogout}\n          isOpen={isNavOpen}\n          setIsOpen={setIsNavOpen}\n          onSettingsClick={() => setIsSettingsOpen(true)}\n      />\n      <div className=\"flex-1 md:pl-[70px] min-w-0\">\n          {renderView()}\n      </div>\n    </main>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAhBA;;;;;;;;;;;;;;;AAqBe,SAAS,KAAK,EAAE,MAAM,EAAE,YAAY,EAAoC;;IACrF,CAAA,GAAA,6JAAA,CAAA,MAAS,AAAD,EAAE;IACV,CAAA,GAAA,6JAAA,CAAA,MAAS,AAAD,EAAE;IAEV,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAQ;IACzD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAE;IACjD,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAsB;IACzE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAE;IAC3D,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAe;IACxE,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAE;IACjD,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IAEzB,CAAA,GAAA,6JAAA,CAAA,YAAe,AAAD;0BAAE;YACd,MAAM,QAAQ;wCAAW;oBACrB,aAAa;gBACjB;uCAAG;YACH;kCAAO,IAAM,aAAa;;QAC5B;yBAAG,EAAE;IAEL,MAAM,UAAU,OAAO,OAAe;QACpC,MAAM,SAAS,MAAM,CAAA,GAAA,qJAAA,CAAA,cAAW,AAAD,EAAE,OAAO;QACxC,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;YAClC,MAAM,QAAQ,OAAO,KAAK;YACzB,eAAe;gBACd,IAAI,MAAM,EAAE;gBACZ,MAAM,MAAM,IAAI;gBAChB,QAAQ,MAAM,MAAM;gBACpB,MAAM,MAAM,IAAI;gBAChB,OAAO,MAAM,KAAK;gBAClB,OAAO,MAAM,KAAK;gBAClB,WAAW,MAAM,SAAS;YAC5B;YAEA,IAAI,MAAM,IAAI,KAAK,SAAS;gBAC1B,cAAc;YAChB,OAAO;gBACL,cAAc;YAChB;QACF;QACA,OAAO;YAAE,SAAS,OAAO,OAAO;YAAE,SAAS,OAAO,OAAO;QAAC;IAC5D;IAEA,MAAM,WAAW,OAAO,MAAc,OAAe;QACnD,MAAM,SAAS,MAAM,CAAA,GAAA,qJAAA,CAAA,eAAY,AAAD,EAAE,MAAM,OAAO;QAC/C,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;YAChC,MAAM;gBACF,OAAO;gBACP,aAAa;YACjB;YACA,MAAM,QAAQ,OAAO,KAAK;YACzB,eAAe;gBACd,IAAI,MAAM,EAAE;gBACZ,MAAM,MAAM,IAAI;gBAChB,QAAQ,MAAM,MAAM;gBACpB,MAAM,MAAM,IAAI;gBAChB,OAAO,MAAM,KAAK;gBAClB,OAAO,MAAM,KAAK;gBAClB,WAAW,MAAM,SAAS;YAC5B;YAEA,IAAI,MAAM,IAAI,KAAK,SAAS;gBAC1B,cAAc;YAChB,OAAO;gBACL,cAAc;YAChB;QACJ;QACA,OAAO;IACT;IAEA,MAAM,eAAe;QACnB,eAAe;QACf,cAAc;IAChB;IAEA,MAAM,mBAAmB,CAAC;QACxB,eAAe,CAAA,OAAQ,OAAO;gBAAE,GAAG,IAAI;gBAAE,GAAG,WAAW;YAAC,IAAI;IAC9D;IAEA,MAAM,uBAAuB,CAAC;QAC5B,kBAAkB;QAClB,cAAc;QACd,6EAA6E;QAC7E,WAAW,IAAM,kBAAkB,OAAO;IAC5C;IAEA,MAAM,aAAa;QACjB,MAAM,QAAQ;YAAE,aAAa,IAAM,aAAa;YAAO,MAAM;QAAY;QACzE,OAAQ;YACN,KAAK;gBACH,qBAAO,6LAAC,oJAAA,CAAA,aAAU;oBAAE,GAAG,KAAK;oBAAE,gBAAgB;;;;;;YAChD,KAAK;gBACH,qBAAO,6LAAC,sJAAA,CAAA,eAAY;oBAAE,GAAG,KAAK;oBAAE,kBAAkB;;;;;;YACpD,KAAK;gBACH,qBAAO,6LAAC,oJAAA,CAAA,aAAU;oBAAE,GAAG,KAAK;;;;;;YAC9B,KAAK;gBACH,qBAAO,6LAAC,uJAAA,CAAA,gBAAa;oBAAE,GAAG,KAAK;;;;;;YACjC,KAAK;gBACH,qBAAO,6LAAC,2JAAA,CAAA,oBAAiB;oBAAE,GAAG,KAAK;;;;;;YACrC,KAAK;gBACH,qBAAO,6LAAC,+JAAA,CAAA,oBAAiB;oBAAE,GAAG,KAAK;;;;;;YACrC,KAAK;gBACF,qBAAO,6LAAC,uJAAA,CAAA,gBAAa;oBAAE,GAAG,KAAK;;;;;;YAClC;gBACE,qBAAO,6LAAC,oJAAA,CAAA,aAAU;oBAAC,MAAM;oBAAa,aAAa,IAAM,aAAa;oBAAO,gBAAgB;;;;;;QACjG;IACF;IAEA,IAAI,WAAW;QACb,qBAAO,6LAAC,uJAAA,CAAA,gBAAa;;;;;IACvB;IAEA,IAAI,CAAC,aAAa;QAChB,qBACE,6LAAC;YAAK,WAAU;sBACd,cAAA,6LAAC,kJAAA,CAAA,WAAQ;gBAAC,SAAS;gBAAS,UAAU;;;;;;;;;;;IAG5C;IAEA,qBACE,6LAAC;QAAK,WAAU;;0BACd,6LAAC,wJAAA,CAAA,iBAAc;gBACb,MAAM;gBACN,cAAc;gBACd,MAAM;gBACN,cAAc;;;;;;0BAEhB,6LAAC,qJAAA,CAAA,cAAW;gBACR,YAAY;gBACZ,eAAe;gBACf,MAAM;gBACN,UAAU;gBACV,QAAQ;gBACR,WAAW;gBACX,iBAAiB,IAAM,kBAAkB;;;;;;0BAE7C,6LAAC;gBAAI,WAAU;0BACV;;;;;;;;;;;;AAIX;GA7IwB;;QAUJ,+HAAA,CAAA,WAAQ;;;KAVJ","debugId":null}}]
}
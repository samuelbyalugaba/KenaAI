{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/db.ts"],"sourcesContent":["\nimport { MongoClient, Db } from 'mongodb';\n\nconst uri = process.env.MONGODB_URI;\nif (!uri) {\n    throw new Error('Please define the MONGODB_URI environment variable inside .env');\n}\n\nlet client: MongoClient;\nlet clientPromise: Promise<MongoClient>;\n\ndeclare global {\n    var _mongoClientPromise: Promise<MongoClient>;\n}\n\nif (process.env.NODE_ENV === 'development') {\n    // In development mode, use a global variable so that the value\n    // is preserved across module reloads caused by HMR (Hot Module Replacement).\n    if (!global._mongoClientPromise) {\n        client = new MongoClient(uri, {});\n        global._mongoClientPromise = client.connect();\n    }\n    clientPromise = global._mongoClientPromise;\n} else {\n    // In production mode, it's best to not use a global variable.\n    client = new MongoClient(uri, {});\n    clientPromise = client.connect();\n}\n\nlet db: Db;\nlet indexesCreated = false;\n\nasync function createIndexes(db: Db) {\n    if (indexesCreated) return;\n\n    try {\n        await Promise.all([\n            db.collection('agents').createIndex({ companyId: 1 }),\n            db.collection('agents').createIndex({ email: 1 }),\n            db.collection('contacts').createIndex({ companyId: 1 }),\n            db.collection('contacts').createIndex({ email: 1 }),\n            db.collection('chats').createIndex({ companyId: 1 }),\n            db.collection('chats').createIndex({ userId: 1 }),\n            db.collection('messages').createIndex({ companyId: 1, sender: 1, timestamp: 1 }),\n            db.collection('announcements').createIndex({ companyId: 1 }),\n            db.collection('campaigns').createIndex({ companyId: 1 }),\n        ]);\n        console.log('Database indexes created successfully.');\n        indexesCreated = true;\n    } catch (error) {\n        console.error('Error creating database indexes:', error);\n    }\n}\n\n\nexport async function getDb(): Promise<Db> {\n    if (db) {\n        return db;\n    }\n    const mongoClient = await clientPromise;\n    const dbName = new URL(uri).pathname.substring(1) || 'kena-ai';\n    db = mongoClient.db(dbName);\n    console.log(`Connected to database: ${db.databaseName}`);\n    \n    // Ensure indexes are created after connection\n    await createIndexes(db);\n\n    return db;\n}\n\n    "],"names":[],"mappings":";;;AACA;;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,IAAI,CAAC,KAAK;IACN,MAAM,IAAI,MAAM;AACpB;AAEA,IAAI;AACJ,IAAI;AAMJ,wCAA4C;IACxC,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI,CAAC,OAAO,mBAAmB,EAAE;QAC7B,SAAS,IAAI,uGAAA,CAAA,cAAW,CAAC,KAAK,CAAC;QAC/B,OAAO,mBAAmB,GAAG,OAAO,OAAO;IAC/C;IACA,gBAAgB,OAAO,mBAAmB;AAC9C,OAAO;;AAIP;AAEA,IAAI;AACJ,IAAI,iBAAiB;AAErB,eAAe,cAAc,EAAM;IAC/B,IAAI,gBAAgB;IAEpB,IAAI;QACA,MAAM,QAAQ,GAAG,CAAC;YACd,GAAG,UAAU,CAAC,UAAU,WAAW,CAAC;gBAAE,WAAW;YAAE;YACnD,GAAG,UAAU,CAAC,UAAU,WAAW,CAAC;gBAAE,OAAO;YAAE;YAC/C,GAAG,UAAU,CAAC,YAAY,WAAW,CAAC;gBAAE,WAAW;YAAE;YACrD,GAAG,UAAU,CAAC,YAAY,WAAW,CAAC;gBAAE,OAAO;YAAE;YACjD,GAAG,UAAU,CAAC,SAAS,WAAW,CAAC;gBAAE,WAAW;YAAE;YAClD,GAAG,UAAU,CAAC,SAAS,WAAW,CAAC;gBAAE,QAAQ;YAAE;YAC/C,GAAG,UAAU,CAAC,YAAY,WAAW,CAAC;gBAAE,WAAW;gBAAG,QAAQ;gBAAG,WAAW;YAAE;YAC9E,GAAG,UAAU,CAAC,iBAAiB,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC1D,GAAG,UAAU,CAAC,aAAa,WAAW,CAAC;gBAAE,WAAW;YAAE;SACzD;QACD,QAAQ,GAAG,CAAC;QACZ,iBAAiB;IACrB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oCAAoC;IACtD;AACJ;AAGO,eAAe;IAClB,IAAI,IAAI;QACJ,OAAO;IACX;IACA,MAAM,cAAc,MAAM;IAC1B,MAAM,SAAS,IAAI,IAAI,KAAK,QAAQ,CAAC,SAAS,CAAC,MAAM;IACrD,KAAK,YAAY,EAAE,CAAC;IACpB,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,GAAG,YAAY,EAAE;IAEvD,8CAA8C;IAC9C,MAAM,cAAc;IAEpB,OAAO;AACX","debugId":null}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/auth.ts"],"sourcesContent":["\n'use server';\n\nimport bcrypt from 'bcrypt';\n\nconst saltRounds = 10;\n\nexport async function hashPassword(password: string): Promise<string> {\n  const salt = await bcrypt.genSalt(saltRounds);\n  const hash = await bcrypt.hash(password, salt);\n  return hash;\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return await bcrypt.compare(password, hash);\n}\n"],"names":[],"mappings":";;;;;;AAGA;;;;;AAEA,MAAM,aAAa;AAEZ,eAAe,aAAa,QAAgB;IACjD,MAAM,OAAO,MAAM,qGAAA,CAAA,UAAM,CAAC,OAAO,CAAC;IAClC,MAAM,OAAO,MAAM,qGAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU;IACzC,OAAO;AACT;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IACjE,OAAO,MAAM,qGAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU;AACxC;;;IARsB;IAMA;;AANA,+OAAA;AAMA,+OAAA","debugId":null}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nexport async function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nexport async function getUsersCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\n// A simple hashing function to create a pseudo-random but consistent number from a string.\nconst simpleHash = (str: string) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash);\n};\n\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        \n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        // Efficiently get conversation counts for all agents in one query\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n\n        const conversationCounts = await messagesCollection.aggregate([\n            { $match: { sender: 'me', companyId: new ObjectId(companyId), timestamp: { $gte: today.toISOString() } } },\n            { $group: { _id: \"$senderId\", count: { $sum: 1 } } }\n        ]).toArray();\n\n        const countsMap = new Map(conversationCounts.map(item => [item._id.toString(), item.count]));\n\n        const agentDataWithStats = agents.map(agent => {\n            const agentIdStr = agent._id.toString();\n            const conversationsToday = countsMap.get(agentIdStr) || 0;\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const hash = simpleHash(agent.name);\n            const randomStatus = statuses[hash % statuses.length];\n\n            let avgResponseTime = \"N/A\";\n            let csat: number | undefined = undefined;\n\n            if (conversationsToday > 0) {\n                const avgResponseMinutes = (hash % 4) + 1; // 1 to 4 minutes\n                const avgResponseSeconds = hash % 60; // 0 to 59 seconds\n                avgResponseTime = `${avgResponseMinutes}m ${avgResponseSeconds}s`;\n                csat = 85 + (hash % 15);\n            }\n\n            return {\n                ...agent,\n                _id: agentIdStr,\n                id: agentIdStr,\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime,\n                csat,\n            };\n        });\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const agentWithStats = await getAgentsByCompany(companyId);\n        const updatedAgent = agentWithStats.find(a => a.id === agentId);\n\n\n        if (updatedAgent) {\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated agent profile for ${name}`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword: string, newPassword: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = '';\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const agentsWithStats = await getAgentsByCompany(companyId);\n            const newAgent = agentsWithStats.find(a => a.id === result.insertedId.toString());\n\n            if (newAgent) {\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function deleteAgent(agentId: string, companyId?: string, deletedBy?: string): Promise<{ success: boolean, message?: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n\n        if (!agentId || !ObjectId.isValid(agentId)) {\n            return { success: false, message: \"Invalid agent ID.\" };\n        }\n\n        const agentToDelete = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (!agentToDelete) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n\n        // Prevent deleting the last admin\n        if (agentToDelete.role === 'admin') {\n            const adminCount = await agentsCollection.countDocuments({ companyId: agentToDelete.companyId, role: 'admin' });\n            if (adminCount <= 1) {\n                return { success: false, message: \"Cannot remove the last administrator.\" };\n            }\n        }\n        \n        const result = await agentsCollection.deleteOne({ _id: new ObjectId(agentId) });\n\n        if (result.deletedCount === 1) {\n            if (companyId && deletedBy) {\n                await logActivity(companyId, deletedBy, 'Delete Agent', `Removed agent: ${agentToDelete.name}`);\n            }\n            return { success: true };\n        }\n\n        return { success: false, message: \"Failed to remove agent.\" };\n    } catch (error) {\n        console.error(\"Delete agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getUsersCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getUsersCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar: '',\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getUsersCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getUsersCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getUsersCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getUsersCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n\nexport async function importContactsFromCSV(contactsData: { name: string; email: string; phone: string }[], companyId: string): Promise<{ success: boolean; message: string; newContacts: User[]; importedCount: number; skippedCount: number; }> {\n    try {\n        const contactsCollection = await getUsersCollection();\n        const newContacts: User[] = [];\n        let importedCount = 0;\n        let skippedCount = 0;\n\n        const companyObjId = new ObjectId(companyId);\n\n        for (const contact of contactsData) {\n            let existingContact = null;\n            if (contact.email) {\n                existingContact = await contactsCollection.findOne({\n                    email: contact.email.toLowerCase(),\n                    companyId: companyObjId\n                });\n            }\n\n            if (existingContact) {\n                skippedCount++;\n                continue;\n            }\n\n            const contactToInsert: Omit<User, 'id' | '_id'> = {\n                name: contact.name,\n                email: contact.email.toLowerCase(),\n                phone: contact.phone,\n                avatar: '',\n                companyId: companyObjId,\n                notes: [],\n                online: false,\n            };\n\n            const result = await contactsCollection.insertOne(contactToInsert as any);\n            if (result.insertedId) {\n                importedCount++;\n                newContacts.push({\n                    ...(contactToInsert as Omit<User, 'id' | '_id'>),\n                    _id: result.insertedId.toString(),\n                    id: result.insertedId.toString(),\n                    companyId: companyId,\n                });\n            }\n        }\n\n        return {\n            success: true,\n            message: `Import complete. Added ${importedCount} new contacts, skipped ${skippedCount} duplicates.`,\n            newContacts,\n            importedCount,\n            skippedCount\n        };\n\n    } catch (error) {\n        console.error(\"CSV import error:\", error);\n        return { success: false, message: \"An unexpected error occurred during import.\", newContacts: [], importedCount: 0, skippedCount: 0 };\n    }\n}\n\nexport async function updateAgentAvatar(agentId: string, avatar: string): Promise<{ success: boolean; message?: string; avatar?: string; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { avatar } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        // Log activity\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n        if (agent) {\n             await logActivity(agent.companyId, agent.name, 'Update Profile', `Updated profile picture`);\n        }\n\n        return { success: true, avatar: avatar };\n    } catch (error) {\n        console.error(\"Update agent avatar error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function scheduleAnalyticsReport(email: string, frequency: string): Promise<{ success: boolean; message: string; }> {\n    try {\n        // In a real application, you would connect to a job scheduler (e.g., BullMQ, cron)\n        // and queue a job to send an email report based on the frequency.\n        // For this demo, we'll just log it to the console.\n        console.log(`Analytics report scheduled for ${email} with frequency: ${frequency}`);\n        \n        // You could also log this as a system activity\n        // await logActivity(companyId, 'System', 'Schedule Report', `Analytics report scheduled for ${email} (${frequency})`);\n\n        return { success: true, message: `Report successfully scheduled for ${email}.` };\n    } catch (error) {\n        console.error(\"Schedule report error:\", error);\n        return { success: false, message: \"An unexpected error occurred while scheduling the report.\" };\n    }\n}\n    \n\n    \n\n    \n\n\n\n\n    "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1545, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 1566, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/intelligent-chat-summary.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview This file defines a Genkit flow for summarizing long chat threads using AI.\n *\n * The flow takes a chat thread as input and returns a concise summary of the conversation's key points.\n *\n * @interface IntelligentChatSummaryInput - Defines the input schema for the intelligentChatSummary function.\n * @interface IntelligentChatSummaryOutput - Defines the output schema for the intelligentChatSummary function.\n * @function intelligentChatSummary - A wrapper function that calls the intelligentChatSummaryFlow with the input and returns the output.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst IntelligentChatSummaryInputSchema = z.object({\n  chatThread: z\n    .string()\n    .describe('The complete chat thread to be summarized.'),\n});\n\nexport type IntelligentChatSummaryInput = z.infer<\n  typeof IntelligentChatSummaryInputSchema\n>;\n\nconst IntelligentChatSummaryOutputSchema = z.object({\n  summary: z.string().describe('A concise summary of the chat thread.'),\n});\n\nexport type IntelligentChatSummaryOutput = z.infer<\n  typeof IntelligentChatSummaryOutputSchema\n>;\n\nexport async function intelligentChatSummary(\n  input: IntelligentChatSummaryInput\n): Promise<IntelligentChatSummaryOutput> {\n  return intelligentChatSummaryFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'intelligentChatSummaryPrompt',\n  input: {schema: IntelligentChatSummaryInputSchema},\n  output: {schema: IntelligentChatSummaryOutputSchema},\n  prompt: `You are an AI expert specializing in summarizing chat threads.\n\n  Please provide a concise summary of the key points in the following chat thread:\n  \\\"{{{chatThread}}}\\\".\n  The summary should be no more than 200 words.\n  `,\n});\n\nconst intelligentChatSummaryFlow = ai.defineFlow(\n  {\n    name: 'intelligentChatSummaryFlow',\n    inputSchema: IntelligentChatSummaryInputSchema,\n    outputSchema: IntelligentChatSummaryOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;CAQC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,oCAAoC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACjD,YAAY,uIAAA,CAAA,IAAC,CACV,MAAM,GACN,QAAQ,CAAC;AACd;AAMA,MAAM,qCAAqC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAMO,eAAe,uBACpB,KAAkC;IAElC,OAAO,2BAA2B;AACpC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAAiC;IACjD,QAAQ;QAAC,QAAQ;IAAkC;IACnD,QAAQ,CAAC;;;;;EAKT,CAAC;AACH;AAEA,MAAM,6BAA6B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC9C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IA3BoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 1630, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-campaign-message.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview A Genkit flow for generating marketing campaign messages.\n *\n * - generateCampaignMessage - A function that generates a campaign message based on a title.\n * - GenerateCampaignMessageInput - The input type for the generateCampaignMessage function.\n * - GenerateCampaignMessageOutput - The return type for the generateCampaignMessage function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst GenerateCampaignMessageInputSchema = z.object({\n  campaignTitle: z.string().describe('The title of the marketing campaign.'),\n});\nexport type GenerateCampaignMessageInput = z.infer<typeof GenerateCampaignMessageInputSchema>;\n\nconst GenerateCampaignMessageOutputSchema = z.object({\n  message: z\n    .string()\n    .describe('The generated marketing message for the campaign.'),\n});\nexport type GenerateCampaignMessageOutput = z.infer<typeof GenerateCampaignMessageOutputSchema>;\n\nexport async function generateCampaignMessage(input: GenerateCampaignMessageInput): Promise<GenerateCampaignMessageOutput> {\n  return generateCampaignMessageFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateCampaignMessagePrompt',\n  input: {schema: GenerateCampaignMessageInputSchema},\n  output: {schema: GenerateCampaignMessageOutputSchema},\n  prompt: `You are a marketing expert. Write a concise and compelling message for a marketing campaign with the following title:\n\"{{{campaignTitle}}}\"\n\nKeep the message under 160 characters. Include a clear call to action.\n`,\n});\n\nconst generateCampaignMessageFlow = ai.defineFlow(\n  {\n    name: 'generateCampaignMessageFlow',\n    inputSchema: GenerateCampaignMessageInputSchema,\n    outputSchema: GenerateCampaignMessageOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,qCAAqC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACrC;AAGA,MAAM,sCAAsC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnD,SAAS,uIAAA,CAAA,IAAC,CACP,MAAM,GACN,QAAQ,CAAC;AACd;AAGO,eAAe,wBAAwB,KAAmC;IAC/E,OAAO,4BAA4B;AACrC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAAkC;IAClD,QAAQ;QAAC,QAAQ;IAAmC;IACpD,QAAQ,CAAC;;;;AAIX,CAAC;AACD;AAEA,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC/C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAxBoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 1691, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {handleLogin as '6049a27b16f34690f84c6af4f9a048cb3293c23e61'} from 'ACTIONS_MODULE0'\nexport {intelligentChatSummary as '401584ba643ed7e5c544243d17d29b0fd409ded3b0'} from 'ACTIONS_MODULE1'\nexport {getChatsByCompany as '40d5d08abcb55310482395efa2b68b3d883c709e39'} from 'ACTIONS_MODULE0'\nexport {getMessagesForChat as '40534236dcc36f51af1a921f1d5dd985231fa0be2f'} from 'ACTIONS_MODULE0'\nexport {sendMessage as '70550f3a06ff63d8c1c6555f235fca6dc7330a34c0'} from 'ACTIONS_MODULE0'\nexport {setChatbotStatus as '609d4f76fb496a216c91066f2d4684c160f7fd02a4'} from 'ACTIONS_MODULE0'\nexport {startNewChats as '78e1313773a3e1763f3457daecfd448d9fb5a79106'} from 'ACTIONS_MODULE0'\nexport {getContactsByCompany as '40ddb22e27e4cef48e6f8b4f4548db5d5d7b59d98c'} from 'ACTIONS_MODULE0'\nexport {addNoteToContact as '780997e968e3cabe30367154f3b8d33efe060f51bd'} from 'ACTIONS_MODULE0'\nexport {assignAgentToContact as '60baf496c3062efe4fd326c7af2943c2196e029cce'} from 'ACTIONS_MODULE0'\nexport {getAgentsByCompany as '4087786a1113f54129434f2a7816d4f589ebf1b846'} from 'ACTIONS_MODULE0'\nexport {importContactsFromCSV as '60d072bc1975e4e5f878dc1c3a7bbba30e68a6f871'} from 'ACTIONS_MODULE0'\nexport {deleteAgent as '703df0e88d6b7f31da31805fe7c8d53353df7e0ee2'} from 'ACTIONS_MODULE0'\nexport {getActivityLogs as '404d8f1b9c2cd44e439a3f4dba37f710171ff8f88b'} from 'ACTIONS_MODULE0'\nexport {scheduleAnalyticsReport as '60f2354c630933e8cfbda63a32de99ef4c111b10e4'} from 'ACTIONS_MODULE0'\nexport {createAnnouncement as '40ff6278859af3f524ec2ac84e79db5390255a1668'} from 'ACTIONS_MODULE0'\nexport {getAnnouncementsByCompany as '409b841e613ce80e5c40df0364f6df47d80421d363'} from 'ACTIONS_MODULE0'\nexport {markAnnouncementAsRead as '60daecd654edd9aad0f66818f3643edb5b83926f6b'} from 'ACTIONS_MODULE0'\nexport {addCommentToAnnouncement as '70fcfed8bffc4caf060f93474e4a8996b303b4b0fc'} from 'ACTIONS_MODULE0'\nexport {updateAgentAvatar as '602c899fcfd2f9f3ff717cf7b6992bb14c9e5acee8'} from 'ACTIONS_MODULE0'\nexport {updateAgentPassword as '7802a2a3c0c2bb253b917e951020eb8b5beaa029c6'} from 'ACTIONS_MODULE0'\nexport {updateAgentProfile as '7c4c24e8dc61bef49f2c2f8a8acc71b5dd4ffb33e3'} from 'ACTIONS_MODULE0'\nexport {getCampaignsByCompany as '40038480f4f658c87505338e9dcd7c2a9a8544e267'} from 'ACTIONS_MODULE0'\nexport {createCampaign as '70a879e7bd08c30d234a83e75003b58f7cb4bfd128'} from 'ACTIONS_MODULE0'\nexport {createAgent as '7efa29b2bf7fa82364aadbf5011c649e7f21f09fbf'} from 'ACTIONS_MODULE0'\nexport {createContact as '783b92989339fb5b73f8cf537b1cd9811ad31c6bdf'} from 'ACTIONS_MODULE0'\nexport {generateCampaignMessage as '4014430748ef3b36b27095eb31bdef60ea95f7dfca'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AACA;AAyBA","debugId":null}},
    {"offset": {"line": 1827, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 1841, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 1855, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAwTsB,cAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAokBsB,oBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA+mBsB,qBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAupBsB,cAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAisBsB,mBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA+sBsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAqcsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAwhBsB,mBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA0gBsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAgEsB,qBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAgesB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAwGsB,qBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAsJsB,4BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAgLsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA8LsB,2BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAgbsB,kBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA20BsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IA0wBsB,iBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { getDb } from \"@/lib/db\";\nimport { hashPassword, verifyPassword } from \"@/lib/auth\";\nimport type { Agent, AgentRole, Announcement, Company, Comment, ActivityLog, User, Note, Chat, Message, Channel, Campaign } from \"@/types\";\nimport { Collection, Db, ObjectId } from \"mongodb\";\n\nasync function getAgentsCollection(): Promise<Collection<Agent>> {\n    const db: Db = await getDb();\n    return db.collection<Agent>('agents');\n}\n\nasync function getCompaniesCollection(): Promise<Collection<Company>> {\n    const db: Db = await getDb();\n    return db.collection<Company>('companies');\n}\n\nasync function getAnnouncementsCollection(): Promise<Collection<Announcement>> {\n    const db: Db = await getDb();\n    return db.collection<Announcement>('announcements');\n}\n\nasync function getActivityLogsCollection(): Promise<Collection<ActivityLog>> {\n    const db: Db = await getDb();\n    return db.collection<ActivityLog>('activity_logs');\n}\n\nasync function getContactsCollection(): Promise<Collection<User>> {\n    const db: Db = await getDb();\n    return db.collection<User>('contacts');\n}\n\nasync function getChatsCollection(): Promise<Collection<Chat>> {\n    const db: Db = await getDb();\n    return db.collection<Chat>('chats');\n}\n\nasync function getMessagesCollection(): Promise<Collection<Message>> {\n    const db: Db = await getDb();\n    return db.collection<Message>('messages');\n}\n\nasync function getCampaignsCollection(): Promise<Collection<Campaign>> {\n    const db: Db = await getDb();\n    return db.collection<Campaign>('campaigns');\n}\n\n\nasync function logActivity(companyId: string | ObjectId, agentName: string, action: string, details: string) {\n    try {\n        const logsCollection = await getActivityLogsCollection();\n        await logsCollection.insertOne({\n            companyId: new ObjectId(companyId),\n            agentName,\n            action,\n            details,\n            timestamp: new Date(),\n        });\n    } catch (error) {\n        console.error(\"Failed to log activity:\", error);\n    }\n}\n\nexport async function getAgentsByCompany(companyId: string): Promise<Agent[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const agentsCollection = await getAgentsCollection();\n        const messagesCollection = await getMessagesCollection();\n        const agents = await agentsCollection.find({ companyId: new ObjectId(companyId) }, { projection: { password: 0 } }).toArray();\n\n        const agentDataWithStats = await Promise.all(agents.map(async (agent) => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const conversationsToday = await messagesCollection.countDocuments({\n                senderId: agent._id,\n                timestamp: { $gte: today.toISOString() } \n            });\n            \n            const statuses: Array<'Online' | 'Offline' | 'Busy'> = ['Online', 'Offline', 'Busy'];\n            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\n\n            return {\n                ...agent,\n                _id: agent._id.toString(),\n                id: agent._id.toString(),\n                companyId: agent.companyId?.toString(),\n                conversationsToday,\n                status: randomStatus,\n                avgResponseTime: `${Math.floor(Math.random() * 5)}m ${Math.floor(Math.random() * 60)}s`,\n                csat: 85 + Math.floor(Math.random() * 15),\n            };\n        }));\n        \n        return agentDataWithStats;\n    } catch (error) {\n        console.error(\"Error fetching agents by company:\", error);\n        return [];\n    }\n}\n\nexport async function createAnnouncement(data: { title: string; content: string; category: string; authorId: string; companyId: string }): Promise<{ success: boolean; message?: string; announcement?: Announcement }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        const agentsCollection = await getAgentsCollection();\n\n        const author = await agentsCollection.findOne({ _id: new ObjectId(data.authorId) });\n        if (!author) {\n            return { success: false, message: \"Author not found.\" };\n        }\n\n        const newAnnouncement: Omit<Announcement, 'id' | '_id'> = {\n            title: data.title,\n            content: data.content,\n            category: data.category as any,\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            companyId: new ObjectId(data.companyId),\n            date: new Date().toISOString(),\n            readBy: [],\n            comments: [],\n        };\n\n        const result = await announcementsCollection.insertOne(newAnnouncement as any);\n        await logActivity(data.companyId, author.name, 'Create Announcement', `Published: \"${data.title}\"`);\n\n\n        if (result.insertedId) {\n            const createdAnnouncement: Announcement = {\n                ...(newAnnouncement as Omit<Announcement, '_id' | 'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(data.companyId).toString(),\n            };\n            return { success: true, announcement: createdAnnouncement };\n        }\n\n        return { success: false, message: \"Failed to create announcement.\" };\n    } catch (error) {\n        console.error(\"Create announcement error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getAnnouncementsByCompany(companyId: string): Promise<Announcement[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const announcementsCollection = await getAnnouncementsCollection();\n        const announcements = await announcementsCollection.find({ companyId: new ObjectId(companyId) }).sort({ date: -1 }).toArray();\n\n        return announcements.map(announcement => ({\n            ...announcement,\n            _id: announcement._id.toString(),\n            id: announcement._id.toString(),\n            companyId: announcement.companyId.toString(),\n            readBy: announcement.readBy || [],\n            comments: (announcement.comments || []).map((comment: Comment) => ({\n                ...comment,\n                timestamp: new Date(comment.timestamp).toISOString(),\n            })),\n        }));\n\n    } catch (error) {\n        console.error(\"Error fetching announcements by company:\", error);\n        return [];\n    }\n}\n\nexport async function markAnnouncementAsRead(announcementId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $addToSet: { readBy: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Mark as read error:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addCommentToAnnouncement(announcementId: string, authorId: string, content: string): Promise<{ success: boolean, comment?: Comment }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const author = await agentsCollection.findOne({ _id: new ObjectId(authorId) });\n        if (!author) return { success: false };\n\n        const newComment: Comment = {\n            id: new ObjectId().toString(),\n            author: {\n                id: author._id.toString(),\n                name: author.name,\n                avatar: author.avatar\n            },\n            content,\n            timestamp: new Date().toISOString(),\n        };\n\n        const announcementsCollection = await getAnnouncementsCollection();\n        await announcementsCollection.updateOne(\n            { _id: new ObjectId(announcementId) },\n            { $push: { comments: newComment } }\n        );\n        \n        return { success: true, comment: newComment };\n\n    } catch (error) {\n        console.error(\"Add comment error:\", error);\n        return { success: false };\n    }\n}\n\n\nexport async function updateAgentProfile(agentId: string, name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        \n        const updateResult = await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { name, email, phone } }\n        );\n\n        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 0) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const updatedAgentDoc = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (updatedAgentDoc) {\n            const { password, ...agentData } = updatedAgentDoc;\n            const updatedAgent: Agent = {\n                ...agentData,\n                _id: updatedAgentDoc._id.toString(),\n                id: updatedAgentDoc._id.toString(),\n                companyId: updatedAgentDoc.companyId?.toString(),\n            };\n            await logActivity(companyId, updatedAgent.name, 'Update Profile', `Updated profile details`);\n            return { success: true, agent: updatedAgent };\n        }\n\n        return { success: false, message: \"Failed to retrieve updated agent.\" };\n    } catch (error) {\n        console.error(\"Update agent profile error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function updateAgentPassword(agentId: string, currentPassword_unused: string, newPassword_unused: string, companyId: string): Promise<{ success: boolean; message: string }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const agent = await agentsCollection.findOne({ _id: new ObjectId(agentId) });\n\n        if (!agent || !agent.password) {\n            return { success: false, message: \"Agent not found.\" };\n        }\n        \n        const isPasswordValid = await verifyPassword(currentPassword_unused, agent.password);\n        if (!isPasswordValid) {\n            return { success: false, message: \"Incorrect current password.\" };\n        }\n\n        const newHashedPassword = await hashPassword(newPassword_unused);\n        await agentsCollection.updateOne(\n            { _id: new ObjectId(agentId) },\n            { $set: { password: newHashedPassword } }\n        );\n        \n        await logActivity(companyId, agent.name, 'Update Password', `Changed password`);\n        return { success: true, message: \"Password updated successfully.\" };\n\n    } catch (error) {\n        console.error(\"Update password error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function handleLogin(email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent }> {\n    try {\n      const agentsCollection = await getAgentsCollection();\n      const agentDoc = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n      if (agentDoc && agentDoc.password) {\n        const isPasswordValid = await verifyPassword(password_unused, agentDoc.password);\n        if (isPasswordValid) {\n          const { password, ...agentData } = agentDoc;\n          const agent: Agent = {\n            ...agentData,\n            _id: agentDoc._id.toString(),\n            id: agentDoc._id.toString(),\n            companyId: agentDoc.companyId?.toString(),\n          };\n          await logActivity(agent.companyId, agent.name, 'Login', `Logged in successfully`);\n          return { success: true, agent: agent };\n        }\n      }\n      return { success: false, message: \"Invalid email or password.\" };\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      return { success: false, message: \"Database connection error.\" };\n    }\n};\n\nexport async function createAgent(name: string, email: string, password_unused: string, role: AgentRole, companyId: string, createdBy: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    try {\n        const agentsCollection = await getAgentsCollection();\n        const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() });\n\n        if (existingAgent) {\n            return { success: false, message: \"An agent with this email already exists.\" };\n        }\n\n        const hashedPassword = await hashPassword(password_unused);\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            role,\n            avatar,\n            phone: '', \n            companyId: new ObjectId(companyId)\n        };\n\n        const result = await agentsCollection.insertOne(agentToInsert as any);\n\n        if (result.insertedId) {\n            const newAgentDoc = await agentsCollection.findOne({ _id: result.insertedId });\n            if (newAgentDoc) {\n                const { password, ...agentData } = newAgentDoc;\n                const newAgent: Agent = {\n                  ...agentData,\n                  _id: newAgentDoc._id.toString(),\n                  id: newAgentDoc._id.toString(),\n                  companyId: newAgentDoc.companyId?.toString(),\n                };\n                await logActivity(companyId, createdBy, 'Create Agent', `Created agent: ${name}`);\n                return { success: true, agent: newAgent };\n            }\n        }\n        return { success: false, message: \"Failed to create agent.\" };\n    } catch (error) {\n        console.error(\"Create agent error:\", error);\n        return { success: false, message: \"An unexpected error occurred while creating the agent.\" };\n    }\n}\n\nexport async function handleSignUp(name: string, email: string, password_unused: string): Promise<{ success: boolean; message?: string; agent?: Agent; }> {\n    const db = await getDb();\n    const session = db.client.startSession();\n    try {\n        let newAgentResult: Agent | undefined;\n        await session.withTransaction(async () => {\n            const companiesCollection = await getCompaniesCollection();\n            const agentsCollection = await getAgentsCollection();\n            const existingAgent = await agentsCollection.findOne({ email: email.toLowerCase() }, { session });\n\n            if (existingAgent) {\n                throw new Error(\"An agent with this email already exists.\");\n            }\n            \n            const companyResult = await companiesCollection.insertOne({\n                name: `${name}'s Company`,\n                createdAt: new Date(),\n            }, { session });\n\n            if (!companyResult.insertedId) {\n                throw new Error(\"Failed to create company.\");\n            }\n            const companyId = companyResult.insertedId;\n            \n            const hashedPassword = await hashPassword(password_unused);\n            const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n            \n            const agentToInsert: Omit<Agent, 'id' | '_id'> = {\n                name,\n                email: email.toLowerCase(),\n                password: hashedPassword,\n                role: 'admin',\n                avatar,\n                phone: '',\n                companyId: companyId,\n            };\n\n            const agentResult = await agentsCollection.insertOne(agentToInsert as any, { session });\n\n             if (!agentResult.insertedId) {\n                throw new Error(\"Failed to create admin agent.\");\n            }\n            \n            await logActivity(companyId, name, 'Sign Up', `Created new company and admin account.`);\n\n            const newAgentDoc = await agentsCollection.findOne({ _id: agentResult.insertedId }, { session });\n            if (newAgentDoc) {\n                 const { password, ...agentData } = newAgentDoc;\n                 newAgentResult = {\n                    ...agentData,\n                    _id: newAgentDoc._id.toString(),\n                    id: newAgentDoc._id.toString(),\n                    companyId: newAgentDoc.companyId?.toString()\n                };\n            }\n        });\n        \n        if (!newAgentResult) {\n            return { success: false, message: \"Failed to retrieve the created agent.\" }\n        }\n\n        return { success: true, agent: newAgentResult };\n    } catch (error: any) {\n        console.error(\"Sign up transaction error:\", error);\n        // Abort transaction on error if it was started\n        if (session.inTransaction()) {\n            await session.abortTransaction();\n        }\n        return { success: false, message: error.message || \"An unexpected error occurred during sign up.\" };\n    } finally {\n        await session.endSession();\n    }\n}\n\n\nexport async function getActivityLogs(companyId: string): Promise<ActivityLog[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const logsCollection = await getActivityLogsCollection();\n        const logs = await logsCollection.find({ companyId: new ObjectId(companyId) }).sort({ timestamp: -1 }).limit(50).toArray();\n\n        return logs.map(log => ({\n            ...log,\n            _id: log._id.toString(),\n            id: log._id.toString(),\n            companyId: log.companyId.toString(),\n            timestamp: log.timestamp.toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching activity logs:\", error);\n        return [];\n    }\n}\n\nexport async function getContactsByCompany(companyId: string): Promise<User[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contacts = await contactsCollection.find({ companyId: new ObjectId(companyId) }).toArray();\n\n        return contacts.map(contact => {\n            const { _id, companyId, ...rest } = contact as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId?.toString(),\n                notes: (contact.notes || []).map((note: Note) => ({\n                    ...note,\n                    timestamp: new Date(note.timestamp).toISOString(),\n                })),\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching contacts:\", error);\n        return [];\n    }\n}\n\nexport async function createContact(name: string, email: string, phone: string, companyId: string): Promise<{ success: boolean; message?: string; contact?: User }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const existingContact = await contactsCollection.findOne({ email: email.toLowerCase(), companyId: new ObjectId(companyId) });\n        if (existingContact) {\n            return { success: false, message: \"A contact with this email already exists.\" };\n        }\n\n        const avatar = `https://picsum.photos/seed/${name.replace(/\\s/g, '')}/100/100`;\n\n        const contactToInsert: Omit<User, 'id' | '_id'> = {\n            name,\n            email: email.toLowerCase(),\n            phone,\n            avatar,\n            companyId: new ObjectId(companyId),\n            notes: [],\n            online: false,\n        };\n\n        const result = await contactsCollection.insertOne(contactToInsert as any);\n        \n        if (result.insertedId) {\n            const newContact: User = {\n                ...(contactToInsert as Omit<User, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, contact: newContact };\n        }\n\n        return { success: false, message: \"Failed to create contact.\" };\n\n    } catch (error) {\n        console.error(\"Create contact error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\n\nexport async function assignAgentToContact(contactId: string, agentId: string): Promise<{ success: boolean }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $set: { assignedAgentId: agentId } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error assigning agent:\", error);\n        return { success: false };\n    }\n}\n\nexport async function addNoteToContact(contactId: string, agentId: string, agentName: string, text: string): Promise<{ success: boolean; note?: Note }> {\n    try {\n        const contactsCollection = await getContactsCollection();\n        \n        const newNote: Note = {\n            id: new ObjectId().toString(),\n            agentId,\n            agentName,\n            text,\n            timestamp: new Date().toISOString()\n        };\n\n        const result = await contactsCollection.updateOne(\n            { _id: new ObjectId(contactId) },\n            { $push: { notes: { $each: [newNote], $position: 0 } } }\n        );\n        \n        if (result.modifiedCount > 0) {\n            return { success: true, note: newNote };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error adding note:\", error);\n        return { success: false };\n    }\n}\n\nexport async function getNotesForContact(contactId: string): Promise<Note[]> {\n     try {\n        if (!contactId || !ObjectId.isValid(contactId)) {\n            return [];\n        }\n        const contactsCollection = await getContactsCollection();\n        const contact = await contactsCollection.findOne({ _id: new ObjectId(contactId) });\n        return (contact?.notes || []).map((note: Note) => ({\n            ...note,\n            timestamp: new Date(note.timestamp).toISOString(),\n        }));\n    } catch (error) {\n        console.error(\"Error fetching notes:\", error);\n        return [];\n    }\n}\n\nexport async function getChatsByCompany(companyId: string): Promise<Chat[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const chatsCollection = await getChatsCollection();\n        const chats = await chatsCollection.aggregate([\n            { $match: { companyId: new ObjectId(companyId) } },\n            { $sort: { timestamp: -1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'userId',\n                    foreignField: '_id',\n                    as: 'user'\n                }\n            },\n            { $unwind: '$user' }\n        ]).toArray();\n\n        return chats.map(chat => {\n            const { _id, companyId, userId, ...rest } = chat as any;\n            return {\n                ...rest,\n                _id: _id.toString(),\n                id: _id.toString(),\n                companyId: companyId.toString(),\n                userId: userId.toString(),\n                messages: [], // Messages will be lazy-loaded\n                user: {\n                    ...chat.user,\n                    _id: chat.user._id.toString(),\n                    id: chat.user._id.toString(),\n                    companyId: chat.user.companyId ? chat.user.companyId.toString() : undefined,\n                }\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching chats by company:\", error);\n        return [];\n    }\n}\n\nexport async function getMessagesForChat(chatId: string): Promise<Message[]> {\n    try {\n        if (!chatId || !ObjectId.isValid(chatId)) {\n            return [];\n        }\n        const messagesCollection = await getMessagesCollection();\n        // Also fetch sender details if it's a user, not an agent ('me')\n        const messages = await messagesCollection.aggregate([\n            { $match: { chatId: new ObjectId(chatId) } },\n            { $sort: { timestamp: 1 } },\n            {\n                $lookup: {\n                    from: 'contacts',\n                    localField: 'senderId',\n                    foreignField: '_id',\n                    as: 'senderInfo'\n                }\n            }\n        ]).toArray();\n\n        return messages.map(msg => {\n            const { _id, chatId, senderId, senderInfo, ...rest } = msg as any;\n            const sender = msg.sender === 'me' ? 'me' : (senderInfo[0] || null);\n\n            if (sender && sender !== 'me') {\n                sender.id = sender._id.toString();\n            }\n\n            return {\n                ...rest,\n                id: _id.toString(),\n                sender,\n            };\n        });\n    } catch (error) {\n        console.error(\"Error fetching messages:\", error);\n        return [];\n    }\n}\n\nexport async function sendMessage(chatId: string, text: string, agentId: string): Promise<{ success: boolean; newMessage?: Message }> {\n    try {\n        const messagesCollection = await getMessagesCollection();\n        const chatsCollection = await getChatsCollection();\n        \n        const timestamp = new Date();\n        const newMessageToInsert: Omit<Message, 'id' | '_id'> = {\n            chatId: new ObjectId(chatId),\n            sender: 'me', // 'me' denotes the agent\n            senderId: new ObjectId(agentId),\n            text,\n            timestamp: timestamp.toISOString(),\n        };\n\n        const result = await messagesCollection.insertOne(newMessageToInsert as any);\n\n        if (result.insertedId) {\n            await chatsCollection.updateOne(\n                { _id: new ObjectId(chatId) },\n                { $set: { lastMessage: text, timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) } }\n            );\n            \n            const finalNewMessage: Message = {\n                ...(newMessageToInsert as Omit<Message, '_id'|'id'>),\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                chatId: newMessageToInsert.chatId.toString(),\n                senderId: newMessageToInsert.senderId.toString(),\n            };\n\n            return { \n                success: true, \n                newMessage: finalNewMessage\n            };\n        }\n        return { success: false };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { success: false };\n    }\n}\n\nexport async function setChatbotStatus(chatId: string, isActive: boolean): Promise<{ success: boolean }> {\n    try {\n        const chatsCollection = await getChatsCollection();\n        await chatsCollection.updateOne(\n            { _id: new ObjectId(chatId) },\n            { $set: { isChatbotActive: isActive } }\n        );\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error setting chatbot status:\", error);\n        return { success: false };\n    }\n}\n\nexport async function startNewChats(users: User[], message: string, companyId: string, agentId: string): Promise<Chat[]> {\n    const chatsCollection = await getChatsCollection();\n    const newOrUpdatedChats: Chat[] = [];\n\n    for (const user of users) {\n        const existingChatDoc = await chatsCollection.findOne({\n            userId: new ObjectId(user.id),\n            companyId: new ObjectId(companyId)\n        });\n\n        if (existingChatDoc) {\n            await sendMessage(existingChatDoc._id.toString(), message, agentId);\n            \n            const updatedChat: Chat = {\n                ...(existingChatDoc as any),\n                _id: existingChatDoc._id.toString(),\n                id: existingChatDoc._id.toString(),\n                userId: existingChatDoc.userId.toString(),\n                companyId: existingChatDoc.companyId.toString(),\n                lastMessage: message,\n                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                user: user,\n                messages: [],\n            };\n            newOrUpdatedChats.push(updatedChat);\n\n        } else {\n            const timestamp = new Date();\n            const newChatData: Omit<Chat, 'id' | '_id'> = {\n                userId: new ObjectId(user.id),\n                companyId: new ObjectId(companyId),\n                lastMessage: message,\n                timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n                unreadCount: 0,\n                priority: 'normal',\n                channel: 'Webchat',\n                isChatbotActive: false,\n                messages: []\n            };\n            const chatResult = await chatsCollection.insertOne(newChatData as any);\n            \n            if (chatResult.insertedId) {\n                await sendMessage(chatResult.insertedId.toString(), message, agentId);\n                const createdChat: Chat = {\n                    ...(newChatData as any),\n                    _id: chatResult.insertedId.toString(),\n                    id: chatResult.insertedId.toString(),\n                    userId: newChatData.userId.toString(),\n                    companyId: newChatData.companyId.toString(),\n                    user: user,\n                    messages: [],\n                };\n                newOrUpdatedChats.push(createdChat);\n            }\n        }\n    }\n    return newOrUpdatedChats;\n}\n\nexport async function createCampaign(data: Partial<Campaign> & { scheduleType?: 'now' | 'later' }, companyId: string, agentId: string): Promise<{ success: boolean; message?: string; campaign?: Campaign; }> {\n    try {\n        const campaignsCollection = await getCampaignsCollection();\n        const contactsCollection = await getContactsCollection();\n        \n        let status: Campaign['status'] = 'Draft';\n        let sentAt: string | undefined = undefined;\n        let delivery = 0;\n        let engagement = 0;\n        let conversion = 0;\n\n        if (data.scheduleType === 'now') {\n            status = 'Completed';\n            sentAt = new Date().toISOString();\n            // Generate mock performance data for immediate campaigns\n            delivery = 95 + Math.random() * 5; \n            engagement = 10 + Math.random() * 15;\n            conversion = 2 + Math.random() * 8; \n\n            // Actually send the messages\n            if (data.audience && data.message) {\n                const audienceContacts = await contactsCollection.find({ _id: { $in: data.audience.map(id => new ObjectId(id)) } }).toArray();\n                const users = audienceContacts.map(c => ({\n                    ...c,\n                    id: c._id.toString(),\n                    _id: c._id.toString(),\n                })) as User[];\n\n                await startNewChats(users, data.message, companyId, agentId);\n            }\n        } else if (data.scheduleType === 'later') {\n            status = 'Scheduled';\n        }\n\n        const newCampaign: Omit<Campaign, 'id' | '_id'> = {\n            title: data.title!,\n            type: data.type || 'Broadcast',\n            status: status,\n            companyId: new ObjectId(companyId),\n            createdAt: new Date().toISOString(),\n            audience: data.audience || [],\n            message: data.message || \"\",\n            sentAt: sentAt,\n            delivery,\n            engagement,\n            conversion,\n        };\n\n        const result = await campaignsCollection.insertOne(newCampaign as any);\n        if (result.insertedId) {\n            const createdCampaign: Campaign = {\n                ...newCampaign,\n                _id: result.insertedId.toString(),\n                id: result.insertedId.toString(),\n                companyId: new ObjectId(companyId).toString(),\n            };\n            return { success: true, campaign: createdCampaign };\n        }\n        return { success: false, message: \"Failed to create campaign.\" };\n    } catch (error) {\n        console.error(\"Create campaign error:\", error);\n        return { success: false, message: \"An unexpected error occurred.\" };\n    }\n}\n\nexport async function getCampaignsByCompany(companyId: string): Promise<Campaign[]> {\n    try {\n        if (!companyId || !ObjectId.isValid(companyId)) {\n            return [];\n        }\n        const campaignsCollection = await getCampaignsCollection();\n        const campaigns = await campaignsCollection.find({ companyId: new ObjectId(companyId) }).sort({ createdAt: -1 }).toArray();\n\n        return campaigns.map(campaign => ({\n            ...campaign,\n            _id: campaign._id.toString(),\n            id: campaign._id.toString(),\n            companyId: campaign.companyId.toString(),\n            createdAt: new Date(campaign.createdAt).toISOString(),\n            sentAt: campaign.sentAt ? new Date(campaign.sentAt).toISOString() : undefined,\n        }));\n    } catch (error) {\n        console.error(\"Error fetching campaigns:\", error);\n        return [];\n    }\n}\n    \n    \n"],"names":[],"mappings":";;;;;;IAqWsB,eAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["\n\"use client\";\n\nimport * as React from \"react\";\nimport { ChatLayout } from \"@/components/dashboard/chat-layout\";\nimport { VerticalNav } from \"@/components/dashboard/vertical-nav\";\nimport { ContactsView } from \"@/components/dashboard/contacts-view\";\nimport { AgentsView } from \"@/components/dashboard/agents-view\";\nimport { DashboardView } from \"@/components/dashboard/dashboard-view\";\nimport type { Agent, User, UserProfile } from \"@/types\";\nimport { AnnouncementsView } from \"@/components/dashboard/announcements-view\";\nimport { SettingsDialog } from \"@/components/dashboard/settings-dialog\";\nimport { CampaignsView } from \"@/components/dashboard/campaigns-view\";\nimport { MyPerformanceView } from \"@/components/dashboard/my-performance-view\";\nimport { AuthForm } from \"@/components/dashboard/auth-form\";\nimport { handleSignUp } from \"@/app/actions\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useSession, signOut } from \"next-auth/react\";\nimport { KenaAILogo } from \"@/components/ui/kena-ai-logo\";\n\n\nexport type View = \"Chat\" | \"Contacts\" | \"Agents\" | \"Dashboard\" | \"Announcements\" | \"History\" | \"Payments\" | \"Settings\" | \"System Settings\" | \"Campaigns\" | \"My Performance\";\n\nexport default function Home({ params, searchParams }: { params: {}; searchParams: {} }) {\n  React.use(params);\n  React.use(searchParams);\n  \n  const [activeView, setActiveView] = React.useState<View>(\"Chat\");\n  const [isNavOpen, setIsNavOpen] = React.useState(false);\n  const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);\n  const [initialContact, setInitialContact] = React.useState<User | null>(null);\n  const { toast } = useToast();\n  const { data: session, status } = useSession();\n  const [currentUser, setCurrentUser] = React.useState<UserProfile | null>(null);\n\n  React.useEffect(() => {\n    if (session?.user) {\n        // This is a bit of a hack to fit the session user into our existing UserProfile type.\n        // In a real app, you'd likely unify these types.\n        const user = session.user as any;\n        const profile: UserProfile = {\n            id: user.id || user.sub, // 'sub' is often used for ID in JWTs\n            name: user.name || 'Kena User',\n            email: user.email || '',\n            avatar: user.image || `https://picsum.photos/seed/${user.name}/100/100`,\n            role: user.role || 'agent', // default role\n            phone: user.phone || '',\n            companyId: user.companyId || '',\n        };\n        setCurrentUser(profile);\n\n        if (profile.role === 'admin' && activeView !== 'Dashboard') {\n            setActiveView('Dashboard');\n        } else if (activeView === 'Dashboard' && profile.role !== 'admin') {\n            setActiveView('Chat');\n        }\n\n    } else {\n        setCurrentUser(null);\n    }\n  }, [session]);\n  \n  const onSignUp = async (name: string, email: string, password_unused: string) => {\n    const result = await handleSignUp(name, email, password_unused);\n    if (result.success && result.agent) {\n        toast({\n            title: \"Account Created!\",\n            description: \"You can now sign in with your new credentials.\",\n        });\n    }\n    return result;\n  }\n\n  const handleLogout = () => {\n    signOut();\n    setCurrentUser(null);\n    setActiveView('Chat');\n  };\n  \n  const handleUpdateUser = (updatedUser: Partial<UserProfile>) => {\n    setCurrentUser(prev => prev ? { ...prev, ...updatedUser } : null);\n  }\n\n  const handleNavigateToChat = (contact: User) => {\n    setInitialContact(contact);\n    setActiveView(\"Chat\");\n    // Reset initialContact after a short delay to allow ChatLayout to pick it up\n    setTimeout(() => setInitialContact(null), 100);\n  }\n\n  const renderView = () => {\n    const props = { onMenuClick: () => setIsNavOpen(true), user: currentUser };\n    switch (activeView) {\n      case \"Chat\":\n        return <ChatLayout {...props} initialContact={initialContact} />;\n      case \"Contacts\":\n        return <ContactsView {...props} onNavigateToChat={handleNavigateToChat} />;\n      case \"Agents\":\n        return <AgentsView {...props} />;\n      case \"Dashboard\":\n        return <DashboardView {...props} />;\n      case \"Announcements\":\n        return <AnnouncementsView {...props} />;\n      case \"My Performance\":\n        return <MyPerformanceView {...props} />;\n      case \"Campaigns\":\n         return <CampaignsView {...props} />;\n      default:\n        return <ChatLayout user={currentUser} onMenuClick={() => setIsNavOpen(true)} initialContact={initialContact} />;\n    }\n  };\n\n  if (status === \"loading\") {\n    return (\n        <main className=\"flex h-screen w-full items-center justify-center bg-background p-4\">\n            <KenaAILogo className=\"h-12 animate-pulse\" />\n        </main>\n    )\n  }\n\n  if (!currentUser) {\n    return (\n      <main className=\"flex h-screen w-full items-center justify-center bg-background p-4 overflow-hidden auth-page-background\">\n        <AuthForm onSignUp={onSignUp} />\n      </main>\n    );\n  }\n\n  return (\n    <main className=\"flex h-screen bg-background\">\n      <SettingsDialog \n        open={isSettingsOpen} \n        onOpenChange={setIsSettingsOpen} \n        user={currentUser}\n        onUserUpdate={handleUpdateUser}\n      />\n      <VerticalNav \n          activeView={activeView} \n          setActiveView={setActiveView} \n          user={currentUser}\n          onLogout={handleLogout}\n          isOpen={isNavOpen}\n          setIsOpen={setIsNavOpen}\n          onSettingsClick={() => setIsSettingsOpen(true)}\n      />\n      <div className=\"flex-1 md:pl-[70px] min-w-0\">\n          {renderView()}\n      </div>\n    </main>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;;;;;;;;;;;;;;;;;AAsBe,SAAS,KAAK,EAAE,MAAM,EAAE,YAAY,EAAoC;IACrF,CAAA,GAAA,qMAAA,CAAA,MAAS,AAAD,EAAE;IACV,CAAA,GAAA,qMAAA,CAAA,MAAS,AAAD,EAAE;IAEV,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAQ;IACzD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAE;IACjD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAE;IAC3D,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAe;IACxE,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,WAAQ,AAAD;IACzB,MAAM,EAAE,MAAM,OAAO,EAAE,MAAM,EAAE,GAAG,CAAA,GAAA,8IAAA,CAAA,aAAU,AAAD;IAC3C,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAsB;IAEzE,CAAA,GAAA,qMAAA,CAAA,YAAe,AAAD,EAAE;QACd,IAAI,SAAS,MAAM;YACf,sFAAsF;YACtF,iDAAiD;YACjD,MAAM,OAAO,QAAQ,IAAI;YACzB,MAAM,UAAuB;gBACzB,IAAI,KAAK,EAAE,IAAI,KAAK,GAAG;gBACvB,MAAM,KAAK,IAAI,IAAI;gBACnB,OAAO,KAAK,KAAK,IAAI;gBACrB,QAAQ,KAAK,KAAK,IAAI,CAAC,2BAA2B,EAAE,KAAK,IAAI,CAAC,QAAQ,CAAC;gBACvE,MAAM,KAAK,IAAI,IAAI;gBACnB,OAAO,KAAK,KAAK,IAAI;gBACrB,WAAW,KAAK,SAAS,IAAI;YACjC;YACA,eAAe;YAEf,IAAI,QAAQ,IAAI,KAAK,WAAW,eAAe,aAAa;gBACxD,cAAc;YAClB,OAAO,IAAI,eAAe,eAAe,QAAQ,IAAI,KAAK,SAAS;gBAC/D,cAAc;YAClB;QAEJ,OAAO;YACH,eAAe;QACnB;IACF,GAAG;QAAC;KAAQ;IAEZ,MAAM,WAAW,OAAO,MAAc,OAAe;QACnD,MAAM,SAAS,MAAM,CAAA,GAAA,kJAAA,CAAA,eAAY,AAAD,EAAE,MAAM,OAAO;QAC/C,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;YAChC,MAAM;gBACF,OAAO;gBACP,aAAa;YACjB;QACJ;QACA,OAAO;IACT;IAEA,MAAM,eAAe;QACnB,CAAA,GAAA,8IAAA,CAAA,UAAO,AAAD;QACN,eAAe;QACf,cAAc;IAChB;IAEA,MAAM,mBAAmB,CAAC;QACxB,eAAe,CAAA,OAAQ,OAAO;gBAAE,GAAG,IAAI;gBAAE,GAAG,WAAW;YAAC,IAAI;IAC9D;IAEA,MAAM,uBAAuB,CAAC;QAC5B,kBAAkB;QAClB,cAAc;QACd,6EAA6E;QAC7E,WAAW,IAAM,kBAAkB,OAAO;IAC5C;IAEA,MAAM,aAAa;QACjB,MAAM,QAAQ;YAAE,aAAa,IAAM,aAAa;YAAO,MAAM;QAAY;QACzE,OAAQ;YACN,KAAK;gBACH,qBAAO,8OAAC,iJAAA,CAAA,aAAU;oBAAE,GAAG,KAAK;oBAAE,gBAAgB;;;;;;YAChD,KAAK;gBACH,qBAAO,8OAAC,mJAAA,CAAA,eAAY;oBAAE,GAAG,KAAK;oBAAE,kBAAkB;;;;;;YACpD,KAAK;gBACH,qBAAO,8OAAC,iJAAA,CAAA,aAAU;oBAAE,GAAG,KAAK;;;;;;YAC9B,KAAK;gBACH,qBAAO,8OAAC,oJAAA,CAAA,gBAAa;oBAAE,GAAG,KAAK;;;;;;YACjC,KAAK;gBACH,qBAAO,8OAAC,wJAAA,CAAA,oBAAiB;oBAAE,GAAG,KAAK;;;;;;YACrC,KAAK;gBACH,qBAAO,8OAAC,4JAAA,CAAA,oBAAiB;oBAAE,GAAG,KAAK;;;;;;YACrC,KAAK;gBACF,qBAAO,8OAAC,oJAAA,CAAA,gBAAa;oBAAE,GAAG,KAAK;;;;;;YAClC;gBACE,qBAAO,8OAAC,iJAAA,CAAA,aAAU;oBAAC,MAAM;oBAAa,aAAa,IAAM,aAAa;oBAAO,gBAAgB;;;;;;QACjG;IACF;IAEA,IAAI,WAAW,WAAW;QACxB,qBACI,8OAAC;YAAK,WAAU;sBACZ,cAAA,8OAAC,8IAAA,CAAA,aAAU;gBAAC,WAAU;;;;;;;;;;;IAGhC;IAEA,IAAI,CAAC,aAAa;QAChB,qBACE,8OAAC;YAAK,WAAU;sBACd,cAAA,8OAAC,+IAAA,CAAA,WAAQ;gBAAC,UAAU;;;;;;;;;;;IAG1B;IAEA,qBACE,8OAAC;QAAK,WAAU;;0BACd,8OAAC,qJAAA,CAAA,iBAAc;gBACb,MAAM;gBACN,cAAc;gBACd,MAAM;gBACN,cAAc;;;;;;0BAEhB,8OAAC,kJAAA,CAAA,cAAW;gBACR,YAAY;gBACZ,eAAe;gBACf,MAAM;gBACN,UAAU;gBACV,QAAQ;gBACR,WAAW;gBACX,iBAAiB,IAAM,kBAAkB;;;;;;0BAE7C,8OAAC;gBAAI,WAAU;0BACV;;;;;;;;;;;;AAIX","debugId":null}}]
}